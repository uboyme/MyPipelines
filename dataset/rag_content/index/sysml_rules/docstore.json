{"docstore/metadata": {"46fda17c-fd7c-4f43-8eaf-aa58a9531ebe": {"doc_hash": "00d3d396d2fb7887a49a80402ebdbe2d9287b4215e0e88af161ff17d207d6a94"}, "293445b0-465b-49b5-b517-0c869601d77d": {"doc_hash": "b9edee26f495fdb45ba2735256af626c24659422295551682ce967aadbc53f21"}, "3803b18f-57e0-4c59-8106-12d18adc0648": {"doc_hash": "d131ace2e48ba13ff8264605d81cd9a8708a9550a2be54e631ade372018521e7"}, "c6ce15b1-05b9-4a69-9cdd-eb2e6c5295ea": {"doc_hash": "05c50685a6680f16413550dc1be45d393b152fed3638553ccac00486f409b803"}, "75f34c2a-2661-426e-8f81-f92a47f50793": {"doc_hash": "363027ea426fc2983d4e24050f4c9b22265bbb4de64ee91b6749d8601d197b38"}, "6aad01c3-03fd-4b73-9317-67e62f52ee96": {"doc_hash": "d30a7f2816e412e325c622af594b22b10092a0fb4c75335413a4ce739583fb88"}, "01f79bd1-86ef-4063-a6a9-97aaa358fb88": {"doc_hash": "15551d883a3e8b5c1f05d22ba529a49d7692d3e5a0700a22ecc1ae692a31a50b"}, "222fe9a6-40dd-4662-bb07-52ec7b41a965": {"doc_hash": "2530c3aadd45c9239e191d2126562d96579170bdda98a669e72deab8e9179a60"}, "68f29305-67de-47e8-a243-991e98ccaacb": {"doc_hash": "4cda528d89a1b74b3caac5151c9ca64a8f47f2d597f2ce28d043baa88ac22d3f"}, "ec7cccb9-2f84-4cb3-b031-7a2bcd76bb28": {"doc_hash": "6cf3b99f4090a279c8cde06a9ddc5f434e260647bf6c86c0b7ab62fdadbfc97a"}, "bb4e85e0-4637-4cf3-9661-ab5752f3c508": {"doc_hash": "0a5d628730ad151f6702c6d182de5ae4fa3dbbd2939977987df5e46252093bf6"}, "a01d77dd-6adc-40ad-ae22-821fa0ce3912": {"doc_hash": "5eb29a69b1c0477d3f481e65f3b63c3bb58d36e5be7035d674115a783b50af04"}, "2bcca698-fed6-4137-8ade-567417ec6e77": {"doc_hash": "fbc6fb492d2c4ff4f9c65244818aee8060b60878c283d6c3d8da5ea671b2b67f"}, "8b927282-8eb0-437d-9cf7-0ac2b53e4696": {"doc_hash": "4e9d0d14df827b8d7fc65e391569aec868ec420e0ca98c8914de03309e159126"}, "c1034ead-36ad-46d6-a460-ee9a02c113d6": {"doc_hash": "b4b7eaa8dcbcfd6d2dc21e0bbbfdd0fc16fe1dfd61c06022d0223f14dda6a906"}, "0c930bab-70f1-4ac4-9f96-68413bc6abfd": {"doc_hash": "55a39cf9e957547a5c16acf16eaf2525bb7a0a0cbfc5d5b714292c19b1b9ff76"}, "1dd2177c-40ad-49ee-a14c-7d8180ec7a00": {"doc_hash": "62059ff7138444f7dc8946b61e5b21efa9b351003a7f9986f21151f01545a5ec"}, "df23f068-69be-4627-86c5-b134e8ca7dd4": {"doc_hash": "5c8d8fdfaf8e815cb139c5750df3cd88a2d5f201c1477f93b8b80f75fb2867f5"}, "2f067223-edf3-46d0-943b-426408cb26b0": {"doc_hash": "8b4213ea1c0ee489c4c8f76d744bd1e47ddedd4e3bc8423243bc65492ce6cbc6"}, "c95fb17b-2553-427e-966b-045cc05109dd": {"doc_hash": "00d3d396d2fb7887a49a80402ebdbe2d9287b4215e0e88af161ff17d207d6a94", "ref_doc_id": "46fda17c-fd7c-4f43-8eaf-aa58a9531ebe"}, "ae47491a-36a0-4f80-9434-b32feb1d0985": {"doc_hash": "b9edee26f495fdb45ba2735256af626c24659422295551682ce967aadbc53f21", "ref_doc_id": "293445b0-465b-49b5-b517-0c869601d77d"}, "6d38edb5-1393-4751-88e8-31d2ecb21a5e": {"doc_hash": "d131ace2e48ba13ff8264605d81cd9a8708a9550a2be54e631ade372018521e7", "ref_doc_id": "3803b18f-57e0-4c59-8106-12d18adc0648"}, "666e0a62-1468-41a4-8d81-11ea7cc5ebd4": {"doc_hash": "05c50685a6680f16413550dc1be45d393b152fed3638553ccac00486f409b803", "ref_doc_id": "c6ce15b1-05b9-4a69-9cdd-eb2e6c5295ea"}, "cb64e6ac-e3a9-4398-be8b-3711862b9377": {"doc_hash": "363027ea426fc2983d4e24050f4c9b22265bbb4de64ee91b6749d8601d197b38", "ref_doc_id": "75f34c2a-2661-426e-8f81-f92a47f50793"}, "d8f96c30-788d-411c-a321-a07fa98d296a": {"doc_hash": "d30a7f2816e412e325c622af594b22b10092a0fb4c75335413a4ce739583fb88", "ref_doc_id": "6aad01c3-03fd-4b73-9317-67e62f52ee96"}, "57a62429-a7b4-461e-a3b5-05aabea429d8": {"doc_hash": "15551d883a3e8b5c1f05d22ba529a49d7692d3e5a0700a22ecc1ae692a31a50b", "ref_doc_id": "01f79bd1-86ef-4063-a6a9-97aaa358fb88"}, "ba4d9ecc-ddf2-4f9e-9222-88f74b03daca": {"doc_hash": "2530c3aadd45c9239e191d2126562d96579170bdda98a669e72deab8e9179a60", "ref_doc_id": "222fe9a6-40dd-4662-bb07-52ec7b41a965"}, "c41409e5-42f0-423c-b65c-0144237b2c31": {"doc_hash": "4cda528d89a1b74b3caac5151c9ca64a8f47f2d597f2ce28d043baa88ac22d3f", "ref_doc_id": "68f29305-67de-47e8-a243-991e98ccaacb"}, "7f393dc7-7e4d-431b-ac35-4cad5b185614": {"doc_hash": "6cf3b99f4090a279c8cde06a9ddc5f434e260647bf6c86c0b7ab62fdadbfc97a", "ref_doc_id": "ec7cccb9-2f84-4cb3-b031-7a2bcd76bb28"}, "6330aa95-eb6a-4085-8763-360ff8fc0f60": {"doc_hash": "0a5d628730ad151f6702c6d182de5ae4fa3dbbd2939977987df5e46252093bf6", "ref_doc_id": "bb4e85e0-4637-4cf3-9661-ab5752f3c508"}, "d8a96758-b321-4c81-8f0c-880bcdeee68a": {"doc_hash": "5eb29a69b1c0477d3f481e65f3b63c3bb58d36e5be7035d674115a783b50af04", "ref_doc_id": "a01d77dd-6adc-40ad-ae22-821fa0ce3912"}, "584c67de-6794-43a2-907b-5752a6629368": {"doc_hash": "fbc6fb492d2c4ff4f9c65244818aee8060b60878c283d6c3d8da5ea671b2b67f", "ref_doc_id": "2bcca698-fed6-4137-8ade-567417ec6e77"}, "26f5fe45-3c92-4ea3-92f7-1882b4e4d12e": {"doc_hash": "4e9d0d14df827b8d7fc65e391569aec868ec420e0ca98c8914de03309e159126", "ref_doc_id": "8b927282-8eb0-437d-9cf7-0ac2b53e4696"}, "0367fccd-0f55-48da-a23f-9d199f99aae6": {"doc_hash": "b4b7eaa8dcbcfd6d2dc21e0bbbfdd0fc16fe1dfd61c06022d0223f14dda6a906", "ref_doc_id": "c1034ead-36ad-46d6-a460-ee9a02c113d6"}, "91dab8aa-63b2-4f6d-a1e7-3e0a7bac30f4": {"doc_hash": "55a39cf9e957547a5c16acf16eaf2525bb7a0a0cbfc5d5b714292c19b1b9ff76", "ref_doc_id": "0c930bab-70f1-4ac4-9f96-68413bc6abfd"}, "125d6b2a-8989-4570-a2e2-7bcdd51a5795": {"doc_hash": "62059ff7138444f7dc8946b61e5b21efa9b351003a7f9986f21151f01545a5ec", "ref_doc_id": "1dd2177c-40ad-49ee-a14c-7d8180ec7a00"}, "6ccf23c8-93db-483f-9bbb-5527f4ba18d3": {"doc_hash": "5c8d8fdfaf8e815cb139c5750df3cd88a2d5f201c1477f93b8b80f75fb2867f5", "ref_doc_id": "df23f068-69be-4627-86c5-b134e8ca7dd4"}, "2d3f7bd6-6f18-4394-bb33-fdbad5a17203": {"doc_hash": "8b4213ea1c0ee489c4c8f76d744bd1e47ddedd4e3bc8423243bc65492ce6cbc6", "ref_doc_id": "2f067223-edf3-46d0-943b-426408cb26b0"}}, "docstore/data": {"c95fb17b-2553-427e-966b-045cc05109dd": {"__data__": {"id_": "c95fb17b-2553-427e-966b-045cc05109dd", "embedding": null, "metadata": {"source": "BDD-ConstraintBlock.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "46fda17c-fd7c-4f43-8eaf-aa58a9531ebe", "node_type": "4", "metadata": {"source": "BDD-ConstraintBlock.txt"}, "hash": "00d3d396d2fb7887a49a80402ebdbe2d9287b4215e0e88af161ff17d207d6a94", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "ConstraintBlock is a SysML modeling element used to define system constraints and formulas, typically corresponding to a uml:Class stereotyped as sysml:ConstraintBlock. It encapsulates parameters (Constraint Parameters) and constraint expressions, representing performance, behavioral, or structural restrictions within the system.\n\nThe following rules apply to XMI-formatted SysML ConstraintBlocks, compatible with additional stereotypes generated by tools such as MagicDraw.\n\n1. Definition and Association Rules for ConstraintBlock\nA ConstraintBlock is represented as a uml:Class element in XMI, identified by the sysml:ConstraintBlock stereotype.\n\nThe ConstraintBlock must reference a base class (base_Class), which is typically a uml:Class element defining relevant attributes and interfaces (e.g., a Block representing system functions or structure).\n\nThe base class usually contains multiple ownedAttribute elements, often defined as uml:Ports, representing the input/output parameters that the ConstraintBlock accepts.\n\n2. Constraint Parameter Rules\nParameters of a ConstraintBlock are stereotyped as ConstraintParameter on the base class\u2019s Ports, indicating that these ports serve as variables for constraint inputs and outputs.\n\nEach ConstraintParameter is bound to a corresponding uml:Port via the base_Port property.\n\nThe naming of Port attributes should be semantically clear (e.g., \u201crevisit time,\u201d \u201ccoverage\u201d) to explicitly express the physical quantity or logical variable represented by the constraint parameter.\n\nConstraintParameters\u2019 ports are generally private (visibility=\"private\") and have aggregation kind composite to ensure encapsulation of constraint parameters.\n\nThe number of ConstraintParameters should comprehensively cover all parameters involved in the ConstraintBlock, ensuring that the constraint expressions are complete and solvable.\n\n3. Constraint Expression Rules\nA ConstraintBlock usually contains ownedRule elements to define constraints. These are of type uml:Constraint and associate with constrained elements (constrainedElement) and expression specifications (specification).\n\nConstraint expressions typically use OpaqueExpression, embedding mathematical formulas or logical statements as text.\n\nConstraint expressions must reference variables based on ports defined as constraint parameters to maintain consistency between parameters and expressions.\n\nFor complex systems, it is recommended to use structured expression languages (such as MathML) or formula languages supported by compatible tools to enhance constraint verifiability.\n\n4. Inheritance and Reuse of ConstraintBlock\nConstraintBlocks can reuse existing constraint definitions via inheritance, expressed through generalization relationships of the base class.\n\nSubclass ConstraintBlocks can extend or refine constraint parameters and expressions defined in parent classes, enabling hierarchical management of constraints.\n\nDuring inheritance, parameter naming and typing compatibility must be ensured to avoid semantic conflicts in constraints.\n\n5. Typical Structure Summary\nConstraintBlock (sysml:ConstraintBlock)\n\nbase_Class: points to the Class owning ports and constraint expressions\n\nConstraintParameter (MD_Customization_for_SysML__additional_stereotypes:ConstraintParameter)\n\nbase_Port: points to the Port defined in the Class\n\nownedRule (uml:Constraint)\n\nconstrainedElement: model elements under constraint\n\nspecification (OpaqueExpression): constraint expression\n\n6. Modeling Recommendations\nMaintain one-to-one correspondence between ConstraintBlock parameters and the base class ports to ensure constraint completeness.\n\nPort names and types must accurately reflect parameter semantics for clarity and subsequent analysis.\n\nConstraint expressions should be as complete and executable as possible to facilitate automated verification and solving.\n\nUse inheritance mechanisms to manage complex constraint systems and improve model maintainability.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3962, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ae47491a-36a0-4f80-9434-b32feb1d0985": {"__data__": {"id_": "ae47491a-36a0-4f80-9434-b32feb1d0985", "embedding": null, "metadata": {"source": "IBD-Connector.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "293445b0-465b-49b5-b517-0c869601d77d", "node_type": "4", "metadata": {"source": "IBD-Connector.txt"}, "hash": "b9edee26f495fdb45ba2735256af626c24659422295551682ce967aadbc53f21", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In SysML\u2019s Internal Block Diagram (IBD), a Connector is used to represent structural connections between internal elements of the system. These connectors typically link different parts or ports to express physical connections, signal transmission, energy flow, or other structural or behavioral dependencies among components. Connectors are one of the core modeling elements in IBDs, providing a clear depiction of communication and coupling relationships within the system.\n\nConnector Definition and XMI Representation\nA Connector is defined within a Block, manifested as an <ownedConnector> child element inside the Block\u2019s uml:Class element.\n\nEach Connector usually contains two <end> elements pointing to the connected parts or ports.\n\nEach ConnectorEnd has a role attribute specifying the connected property, while the optional partWithPort attribute indicates the connection is established on a port of a particular part.\n\nFor connections involving nested structures\u2014such as ports or properties of parts nested within other parts\u2014<sysml:NestedConnectorEnd> must be used, with the propertyPath attribute explicitly defining the connection path.\n\nHandling Nested Connections\nWhen a connector spans multiple nested levels (e.g., connecting a subpart\u2019s subpart), the use of sysml:NestedConnectorEnd is mandatory.\n\nThe propertyPath records the path from the top-level Block down through successive nested properties, with multiple nested property IDs separated by spaces.\n\nThis mechanism ensures that modeling tools can accurately locate connector endpoints, which is critical for multi-level hierarchical structures.\n\nFailure to correctly set nested paths can lead to model errors or ambiguous behavioral semantics.\n\nSemantic and Modeling Rules for Connectors\nBoth endpoints of a Connector must be declared within the current Block\u2019s scope; connections cannot cross into other Blocks.\n\nConnected properties or ports should have matching types or consistent communication semantics\u2014for example, connecting two ports of the same ValueType, or connecting a ProxyPort with its corresponding InterfaceBlock type port.\n\nSelf-connections (connecting a property to itself) should be avoided unless explicitly intended and clearly documented within the model.\n\nModeling Best Practices\nIt is recommended to name Connectors, especially in complex system structures with numerous connections, to improve model readability and maintainability.\n\nWhen connecting ports, prioritize using ProxyPort combined with InterfaceBlock to enhance modularity and decoupling.\n\nBefore defining Connectors, ensure all involved properties and ports are defined to avoid referencing non-existent or undefined model elements, preventing modeling errors.\n\nSpecial Cases and Extensions\nIf the Connector represents a condition where two property values remain equal\u2014such as establishing equality constraints between simulation parameters\u2014the BindingConnector stereotype can be applied.\n\nIn IBDs, such binding connectors are typically used to synchronize parameter values or model structural consistency.\n\nFor modeling physical or information flows (e.g., electrical current, data communication), ItemFlow or InformationFlow may be defined on the Connector, combined with directional modeling on ports using FlowProperty.\n\nXMI Structure Overview\nThe main elements involved in representing a Connector in XMI include:\n\numl:Connector (the connector itself)\n\numl:ConnectorEnd (the two connection endpoints)\n\nOptional sysml:BindingConnector stereotype (for binding connectors)\n\nsysml:NestedConnectorEnd (for nested path specification)\n\nThe use of propertyPath depends on whether the connection path involves nested parts.\n\nPrecise modeling of these structures is essential for model interoperability (e.g., XMI export) and tool compatibility.\n\nSummary\nConnectors in IBD serve not only as structural links but also express the hierarchical nature of the model. Correct and rigorous use of Connectors\u2014adhering to rules regarding nested paths, type consistency, and connection boundaries\u2014is critical to ensuring the correctness and engineering feasibility of SysML models.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4132, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6d38edb5-1393-4751-88e8-31d2ecb21a5e": {"__data__": {"id_": "6d38edb5-1393-4751-88e8-31d2ecb21a5e", "embedding": null, "metadata": {"source": "BDD-InterfaceBlock.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "3803b18f-57e0-4c59-8106-12d18adc0648", "node_type": "4", "metadata": {"source": "BDD-InterfaceBlock.txt"}, "hash": "d131ace2e48ba13ff8264605d81cd9a8708a9550a2be54e631ade372018521e7", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "InterfaceBlock is a key SysML modeling element used to define interface specifications, typically describing communication boundaries and interaction contracts between systems or subsystems. It is essentially a specialized class (uml:Class), distinguished by the stereotype sysml:InterfaceBlock. An InterfaceBlock mainly consists of properties (Ports or Properties) and ports (such as Port, ProxyPort, FlowProperty), reflecting the structural and behavioral characteristics of the interface.\n\n1. Definition and XMI Representation of InterfaceBlock\nIn XMI format, an InterfaceBlock is represented as a uml:Class element stereotyped with sysml:InterfaceBlock. It is associated with a corresponding base class (base_Class attribute points to the Class\u2019s xmi:id).\n\nThe base class contains the concrete interface structure definitions, including ports and properties.\n\n2. Property and Port Definition Rules\nInterface elements defined in the base class associated with an InterfaceBlock are typically ownedAttribute elements, with types mostly uml:Port or uml:Property.\n\nThese attributes must have explicit names that represent the meaning of data or signals in the interface (e.g., \u201cp1\u201d, \u201cp2\u201d, or properties referencing other classes).\n\nVisibility of these attributes is usually set to public to ensure interface openness.\n\nAggregation kinds are generally composite (ports as composite parts) or default association relationships.\n\n3. Port Types and Stereotype Extensions\nCommon port types within InterfaceBlock include:\n\nPort: Standard ports representing interface connection points.\n\nProxyPort: Marked with the stereotype sysml:ProxyPort, indicating the port acts as a proxy, typically used to forward messages or signals. In examples, a ProxyPort is linked via the base_Port property to a specific Port in the base class.\n\nFlowProperty: Marked with the stereotype sysml:FlowProperty, representing properties with data flow direction, usually accompanied by a direction attribute (such as in, out, or inout) to specify data flow direction explicitly.\n\n4. Directionality and Data Flow Specifications\nFor FlowProperty, the direction must be explicitly specified to indicate whether the data flow is input (in), output (out), or bidirectional (inout).\n\nThe directionality of ports and properties is central to the interface specification, ensuring consistent understanding of data and signal flow between interacting parties.\n\nProxyPorts typically serve as proxies for ports and do not individually specify direction; their corresponding base class Ports carry the responsibility for concrete data interactions.\n\n5. Association Types and Reuse\nInterfaceBlock supports type associations with other classes, e.g., the ownedAttribute in the base class may point to other classes via the type attribute, representing hierarchical and reusable interface structures.\n\nThis association supports modular interface design, allowing complex interfaces to be composed of multiple sub-interfaces.\n\nInheritance and implementation mechanisms can extend or refine InterfaceBlocks, enabling polymorphism of interfaces.\n\n6. Typical Structure Summary\nInterfaceBlock (sysml:InterfaceBlock)\n\nbase_Class: points to the Class owning interface properties\n\nownedAttribute (uml:Port or uml:Property)\n\nname: name of the port or property\n\nvisibility: typically public\n\naggregation: e.g., composite\n\ntype: if associated with other classes, points to their xmi:id\n\nStereotyped port extensions:\n\nProxyPort (sysml:ProxyPort)\n\nbase_Port: links to base class Port\n\nFlowProperty (sysml:FlowProperty)\n\nbase_Property: links to base class Property\n\ndirection: in / out / inout\n\n7. Modeling Recommendations\nAttribute and port names in the base class of an InterfaceBlock should accurately reflect interface semantics to ensure clarity of interface definitions.\n\nPort types and directions must be clearly defined to avoid ambiguities in interface usage.\n\nAppropriately use ProxyPort and FlowProperty stereotypes to enhance expressiveness and reusability of interfaces.\n\nInterface design should consider modularization and hierarchical structure to facilitate maintenance and scalability.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4142, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "666e0a62-1468-41a4-8d81-11ea7cc5ebd4": {"__data__": {"id_": "666e0a62-1468-41a4-8d81-11ea7cc5ebd4", "embedding": null, "metadata": {"source": "IBD-InformationFlow.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c6ce15b1-05b9-4a69-9cdd-eb2e6c5295ea", "node_type": "4", "metadata": {"source": "IBD-InformationFlow.txt"}, "hash": "05c50685a6680f16413550dc1be45d393b152fed3638553ccac00486f409b803", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In SysML\u2019s Internal Block Diagram (IBD), InformationFlow is used to model the transmission of information or signals between different parts of the system. It does not directly represent a structural connection but semantically describes who transmits what information to whom. Typical applications include representing flows of control commands, data instructions, status feedback, and other non-physical entities. In XMI representation, InformationFlow corresponds to the uml:InformationFlow element, often used in conjunction with Connectors to ensure consistency between model structure and behavior.\n\nKey Elements of InformationFlow\nEach InformationFlow must specify one or more conveyed information items, which are usually of type InformationItem. These represent the abstract content of the transmission.\n\nThe conveyed information items do not require detailed attribute definitions but serve to describe the content being transferred. For example, a power control information flow may convey an information item named \"Pwr Control\" without detailing its internal data structure.\n\nSource and Target\nThe two core components of InformationFlow are informationSource and informationTarget, indicating the origin and receiver of the information.\n\nIn an IBD, these typically point to Ports of a Block, representing the output interface and the receiving interface, respectively.\n\nThese Ports must be predefined in the model and have clear directionality (e.g., using ProxyPort or FlowPort with defined directions).\n\nWhen nested part structures are involved, informationSource and informationTarget can be precisely located via the path mapping of ConnectorEnd to a specific sub-level port within the subsystem.\n\nRealizingConnector Association\nTo enable structured modeling, an InformationFlow can be linked to an existing uml:Connector via the realizingConnector property, indicating that the information flow physically or logically transmits along that specific connector.\n\nThis association ensures the modeled information exchange is grounded in an actual structural connection.\n\nIf no realizingConnector is defined, the InformationFlow is considered abstract and will not be reflected in the physical connection structure.\n\nModeling Best Practices\nEach InformationFlow should have a clearly defined name to enhance readability and traceability.\n\nIf the conveyed information item originates from an InformationItem\u2019s ownedUseCase, it is recommended to nest the information item within a classifier and reference the transmitted object explicitly via xmi:idref.\n\nThis practice supports reuse and consistency verification, especially in complex systems or multi-level subsystems with numerous information flows.\n\nModeling Constraints\nInformationFlows must not be defined between nonexistent or unconnected source and target ends.\n\nConveyed information item types must exist within the model and should avoid duplicate definitions.\n\nThe information source and target must be recognizable model elements (such as Ports, Properties, or the classes themselves).\n\nWhen using realizingConnector, its ConnectorEnd references must point to valid connection endpoints.\n\nRecommended Usage\nIt is advised to combine InformationFlow modeling with FlowPort or InterfaceBlock to improve semantic expressiveness.\n\nInformationFlow modeling not only enhances the behavioral description capability of the model but also facilitates future simulation, verification, and requirements traceability.\n\nThus, InformationFlow acts as a critical bridge connecting structural modeling with behavioral modeling.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3586, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "cb64e6ac-e3a9-4398-be8b-3711862b9377": {"__data__": {"id_": "cb64e6ac-e3a9-4398-be8b-3711862b9377", "embedding": null, "metadata": {"source": "ACT-TestCase.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "75f34c2a-2661-426e-8f81-f92a47f50793", "node_type": "4", "metadata": {"source": "ACT-TestCase.txt"}, "hash": "363027ea426fc2983d4e24050f4c9b22265bbb4de64ee91b6749d8601d197b38", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In SysML, TestCases can be modeled by associating uml:Activity or uml:Operation elements with the sysml:TestCase stereotype to realize verification of specific system requirements. In typical usage, an Activity represents the detailed execution flow of a test behavior, while the Activity\u2019s specification attribute references a uml:Operation. This Operation is in turn referenced by the sysml:TestCase through the base_Operation property, forming a complete test modeling chain. This pattern embodies the principle that: the Operation defines the test interface, the Activity describes the test procedure, and the TestCase defines the test requirement.\n\nSpecifically, a TestCase is usually implemented by an Activity behavior that realizes the test flow. This Activity may contain multiple CallBehaviorAction nodes, each invoking a lower-level Activity representing operational steps in the system test, such as \u201cSense Thermal Emissions,\u201d \u201cDisplay Imagery,\u201d or \u201cMeasure Resolution.\u201d These nodes are connected via ControlFlow and ObjectFlow edges to model control logic, the sequence of data transfer, and dependencies among input/output objects. This structure clearly expresses the logical integrity and traceability of the test process.\n\nIn behavior modeling, test activities are partitioned into different ActivityPartitions to express the responsibilities or roles of participating objects in the system test. For example, a test may involve objects such as the System-Under-Test, Signal Processor, and Display, each allocated to distinct ActivityPartitions. Each Partition uses the represents attribute to link to a uml:Class (representing the corresponding physical or logical component), and allocation from behavior to structure is realized via AllocateActivityPartition relationships. This partitioning mechanism enhances the structural organization of the test model and supports alignment between the model and system architecture.\n\nAdditionally, common modeling elements in test activities include InitialNode and ActivityFinalNode, which mark the start and end of the test flow; multiple InputPins and OutputPins serve as parameters or results of actions, respectively used to input test conditions or capture test outcomes; and combinations of CallBehaviorActions form the backbone of the test flow, enabling modular reuse of existing sub-test logic or subsystem behaviors.\n\nWhen using uml:Operation as the core organizing element for tests, the model typically exhibits the following structure: an Operation node is linked via its method property to an Activity, and this Operation is simultaneously referenced by a TestCase. This modeling pattern emphasizes interface-driven design, suitable for validation modeling and requirements traceability scenarios, facilitating integration with requirement models. Conversely, if a TestCase directly references a base_Behavior as an Activity, it is more appropriate for process-oriented or flow-driven modeling contexts.\n\nOverall, testing modeling in SysML stresses the tight integration of structure, behavior, and verification objectives. TestCases describe not only the test behavior itself (e.g., specific flows, invocations, decisions) but also establish relationships with system components through partitions, define interface semantics through Operations, and express process flows through behavioral modeling. This combination of interface, behavior, and structure supports the reusability, verifiability, and maintainability of test models.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3508, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d8f96c30-788d-411c-a321-a07fa98d296a": {"__data__": {"id_": "d8f96c30-788d-411c-a321-a07fa98d296a", "embedding": null, "metadata": {"source": "ACT-Activity.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "6aad01c3-03fd-4b73-9317-67e62f52ee96", "node_type": "4", "metadata": {"source": "ACT-Activity.txt"}, "hash": "d30a7f2816e412e325c622af594b22b10092a0fb4c75335413a4ce739583fb88", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In SysML, an Activity is a core modeling element used to describe system behavior or control logic flows. It can be used to model the functions performed by the system, the sequence of tasks, the flow of data, and input/output interfaces. An Activity can declare its external interfaces by defining Parameters, representing the inputs and outputs required by the behavior. Each parameter is typically modeled in the diagram through an ActivityParameterNode, which allows the parameter to participate in control flows or data flows as input/output ports. The direction of a parameter (such as in, out, inout) is specified by the direction attribute, directly affecting the semantic meaning of the behavior\u2019s interface.\n\nBesides parameterized interface modeling, an Activity can also serve as a container for composite behavior by aggregating other Activity elements through Properties. This modeling approach is common in task integration or system-level behavior modeling scenarios, where a main Activity organizes multiple sub-activities via aggregation properties, forming a hierarchical behavior structure. The relationships between properties are connected through Associations, indicating the composition relationship between the main activity and sub-activities. This composite modeling pattern facilitates the organization of complex behaviors, supports reuse, replacement, and composition of behaviors, and helps build task libraries or behavior templates.\n\nIn more common flow modeling, an Activity can contain multiple Action nodes (such as CallBehaviorAction, OpaqueAction, etc.), which are connected by ControlFlows to describe the control order of behaviors. Control flow models may also include control nodes such as InitialNode, DecisionNode, ForkNode, and MergeNode, used to represent decision points, concurrency, synchronization, and other control logic. This modeling approach suits clearly defined control flows or task scheduling logic.\n\nIn complex behavior modeling, StructuredActivityNode can be used to encapsulate local behaviors, forming modular behavior blocks with local variables and flows. Additionally, structures like InterruptibleActivityRegion can express boundaries and logical conditions where behavior interruptions may occur.\n\nOverall, the SysML Activity element provides a highly flexible modeling mechanism supporting multi-level modeling needs \u2014 from atomic behavior modeling (e.g., action nodes) to system-level composite behavior modeling (e.g., property aggregation), and to interface modeling (e.g., parameter nodes). In practice, the appropriate modeling style should be chosen based on modeling objectives:\n\nIf emphasizing behavioral flow, use Action + ControlFlow;\n\nIf emphasizing interface and data interaction, use Parameter + ActivityParameterNode;\n\nIf emphasizing structure and hierarchical organization, use the composite activity modeling pattern with Property + Association.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2929, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "57a62429-a7b4-461e-a3b5-05aabea429d8": {"__data__": {"id_": "57a62429-a7b4-461e-a3b5-05aabea429d8", "embedding": null, "metadata": {"source": "REQ-DeriveReqt.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "01f79bd1-86ef-4063-a6a9-97aaa358fb88", "node_type": "4", "metadata": {"source": "REQ-DeriveReqt.txt"}, "hash": "15551d883a3e8b5c1f05d22ba529a49d7692d3e5a0700a22ecc1ae692a31a50b", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In SysML requirements (REQ) modeling, the DeriveReqt (Derived Requirement) relationship is used to indicate that one requirement is \u201cderived from\u201d another higher-level or more abstract requirement. This relationship reflects the logical deduction process among system requirements and commonly appears during the hierarchical decomposition of system requirements into subsystem-level requirements. It is especially useful for tracing the origin and rationale of requirements and ensuring design consistency.\n\nIn the .xmi file, DeriveReqt is a stereotype extension of the UML uml:Abstraction element. Each sysml:DeriveReqt element is bound to a corresponding UML Abstraction element via the base_Abstraction attribute, thereby inheriting UML\u2019s modeling semantics of \u201cabstraction.\u201d The Abstraction itself is a structural dependency representing a semantic dependency between two elements. In the case of DeriveReqt, the two elements must be UML Class elements stereotyped as sysml:Requirement, referenced by the client and supplier properties respectively.\n\nSpecifically, the client represents the derived requirement\u2014that is, the newly created, more detailed requirement\u2014while the supplier represents the original requirement from which the derivation is made. This directionality is similar to the \u201crefine\u201d or \u201csatisfy\u201d relationships and must be strictly semantically consistent. For example, if requirement A (supplier) represents an overall system quality requirement, and requirement B (client) refines A\u2019s quality requirement specifically for the \u201cStructural Subsystem,\u201d then the relationship should be modeled as B DeriveReqt A.\n\nEach requirement involved in a DeriveReqt relationship is typically declared as a uml:Class element via <nestedClassifier> or <packagedElement>, with the sysml:Requirement stereotype applied. This stereotype connects to the UML class through the base_Class attribute and defines two core properties:\n\nId: The requirement identifier, supporting hierarchical numbering schemes (e.g., 3.1.1, 5.2) to express structural decomposition.\n\nText: A natural language description of the requirement content.\n\nIn modeling practice, the use of DeriveReqt includes the following key points:\n\nClear Requirement Source: Derived requirements must originate logically or functionally from a higher-level requirement; creating low-level requirements without basis is discouraged. The supplier property should explicitly indicate the logical origin.\n\nSupports Downward Decomposition: Commonly used in scenarios where system requirements are progressively derived into subsystem or component requirements. When combined with \u201cContainment\u201d structures, it enables tracing both structural and semantic decomposition paths.\n\nSupports Requirement Verification Traceability: The derivation path provides traceable evidence for verification activities and the formulation of test cases, assisting in building a complete V-model development process.\n\nGraphical Presentation Support: In modeling tools such as MagicDraw or Papyrus, DeriveReqt relationships are shown in Requirement Diagrams as dependency arrows labeled \u00abderiveReqt\u00bb, pointing from the client (derived requirement) to the supplier (source requirement), facilitating quick identification by engineers.\n\nAvoid Direction Errors: Modelers must carefully ensure the correct directionality of the Abstraction. Reversing client and supplier leads to incorrect derivation logic and negatively impacts requirement verification and design consistency analyses.\n\nIn summary, DeriveReqt is a core semantic relationship in SysML requirements modeling. It not only reflects structural logic in the requirements phase but also provides essential support for subsequent requirements traceability, verification workflow establishment, and change management. Modelers should use this relationship judiciously to guarantee the traceability, verifiability, and logical closure of the requirements model.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3954, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "ba4d9ecc-ddf2-4f9e-9222-88f74b03daca": {"__data__": {"id_": "ba4d9ecc-ddf2-4f9e-9222-88f74b03daca", "embedding": null, "metadata": {"source": "PAR-caused_by.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "222fe9a6-40dd-4662-bb07-52ec7b41a965", "node_type": "4", "metadata": {"source": "PAR-caused_by.txt"}, "hash": "2530c3aadd45c9239e191d2126562d96579170bdda98a669e72deab8e9179a60", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The caused_by relationship is used to model a causal dependency where one problem or failure (Problem/Failure) is caused by another problem or failure. It is implemented by applying a custom stereotype named caused_by (typically referenced as Custom_Stereotypes:caused_by) on the uml:Dependency element. This modeling mechanism explicitly indicates that a higher-level problem in the system is triggered by a lower-level or preceding issue, facilitating fault propagation analysis, causal tracing, and the formulation of mitigation strategies.\n\nEach caused_by relationship structurally relies on a uml:Dependency element, where the client represents the affected problem (i.e., the effect), and the supplier denotes the cause of the problem (i.e., the root cause). For example, if a Trajectory Failure is caused by an Attitude Control Failure, then Trajectory Failure is modeled as the client, and Attitude Control Failure as the supplier. This approach clearly depicts the fault propagation chain, supporting subsequent Failure Mode and Effects Analysis (FMEA) and related activities.\n\nWithin the model context, these clients and suppliers are typically uml:Class elements stereotyped with sysml:ConstraintBlock, representing system problems or behavioral failure conditions defined by specific constraints. These elements often include ownedRule and OpaqueExpression constraints to capture the problem's triggering logic or evaluation criteria. For instance, a Mission Failure might have a constraint specifying it occurs only under certain preconditions, which themselves may be triggered by Launch Failure or other sub-problems via caused_by relationships.\n\nWhen modeling, special attention must be given to the strong directional semantics of caused_by. Modelers must ensure the semantics align with the actual causal logic, where the \"cause\" is always the supplier, and the \"effect\" is the client. To enhance semantic clarity, it is recommended to use standardized naming conventions for each Dependency and its caused_by relationship, such as \u201cFailure A caused_by Failure B,\u201d or to provide natural language descriptions clarifying the logic of the dependency.\n\nFrom an engineering perspective, caused_by provides an efficient causal chain modeling mechanism, especially suited for complex systems involving fault propagation, requirements and problem traceability, safety modeling, and root cause analysis. Combined with model validation techniques, it can identify unreasonable dependency chains, causal loops, and other potential model defects, thereby improving the completeness and consistency of problem modeling.\n\nIn summary, caused_by is one of the key modeling relationships in PAR (Problem Analysis and Resolution) diagrams. It leverages uml:Dependency to implement causal modeling, explicitly defining trigger relations between problems. It supports problem identification, propagation path tracing, and system-level countermeasure planning, forming a critical foundation for system problem modeling and engineering decision-making.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3049, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "c41409e5-42f0-423c-b65c-0144237b2c31": {"__data__": {"id_": "c41409e5-42f0-423c-b65c-0144237b2c31", "embedding": null, "metadata": {"source": "REQ-Requirement.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "68f29305-67de-47e8-a243-991e98ccaacb", "node_type": "4", "metadata": {"source": "REQ-Requirement.txt"}, "hash": "4cda528d89a1b74b3caac5151c9ca64a8f47f2d597f2ce28d043baa88ac22d3f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In SysML requirements modeling, the Requirement is the most fundamental modeling element used to express the conditions or capabilities that a system must satisfy throughout development, design, manufacturing, and verification processes. SysML extends the UML Class element by defining the sysml:Requirement stereotype, integrating general modeling language constructs with engineering requirement semantics, thereby enabling modeling tools to express both system structure and requirement logic simultaneously.\n\nIn the .xmi file, a Requirement exists as a uml:Class element, semantically annotated with the sysml:Requirement stereotype. Each sysml:Requirement is bound to a specific uml:Class instance via the base_Class attribute, establishing a unique identifier and structural information for the requirement. This uml:Class typically includes a name attribute to denote the requirement\u2019s name. The sysml:Requirement stereotype itself defines two key attributes:\n\nId: The requirement identifier, used for uniquely identifying the requirement item. This identifier usually adopts a hierarchical numbering scheme (e.g., 3.1, 3.1.4, 75.1.2) to express the requirement\u2019s hierarchical structure, facilitating management and traceability.\n\nText: The textual content of the requirement, which is the natural language description that clearly states the functions, performances, constraints, or other conditions the system must meet. This field serves as a direct explanation for the engineering team and is the primary basis for requirement review and verification.\n\nStructurally, SysML allows multiple child uml:Class elements to be nested via the nestedClassifier mechanism, thereby forming a structured representation of parent and child requirements. Each subclass can be marked as a new Requirement instance with its own unique identifier and text. This nesting structure not only reflects the logical decomposition of requirements but also facilitates modeling tools in automatically organizing the requirement tree structure (such as expanding packages in Requirements Diagrams).\n\nKey modeling rules and considerations for using Requirement include:\n\nUnique binding to a UML Class: Each sysml:Requirement must uniquely bind to one base_Class element; multiple bindings are prohibited to avoid ambiguity.\n\nLogical consistency of requirement identifiers: Hierarchical numbering (e.g., 3.1.4, 75.1.2) should reflect the semantic structure of the system requirements and clearly express parent-child relationships.\n\nClear, standardized, and verifiable textual descriptions: The Text attribute content should follow engineering requirement writing standards (such as IEEE 830 or INCOSE formats) to ensure that the requirements are measurable, traceable, and testable.\n\nSupport for layered requirement structuring: Parent-child logical and structural relationships can be represented through nested classes, but nested classes must also be properly annotated with the sysml:Requirement stereotype.\n\nGraphical representation support: In modeling tools, requirements are typically displayed as boxes showing the Id and Text, and linked to other model elements via dependency relationships (e.g., deriveReqt, refine, satisfy), supporting full lifecycle traceability.\n\nIn summary, Requirement modeling in SysML provides a standardized and structured way for systems engineering to express requirements. This approach not only visualizes and manages requirements but also deeply integrates them with other model elements such as structure, behavior, and constraints, supporting a closed-loop system development process. Modelers should appropriately apply the Requirement stereotype and nesting mechanisms, combined with hierarchical numbering and clear textual descriptions, to build a logically rigorous, hierarchically clear, and content-complete requirements modeling framework.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3875, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "7f393dc7-7e4d-431b-ac35-4cad5b185614": {"__data__": {"id_": "7f393dc7-7e4d-431b-ac35-4cad5b185614", "embedding": null, "metadata": {"source": "PKG-Package.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "ec7cccb9-2f84-4cb3-b031-7a2bcd76bb28", "node_type": "4", "metadata": {"source": "PKG-Package.txt"}, "hash": "6cf3b99f4090a279c8cde06a9ddc5f434e260647bf6c86c0b7ab62fdadbfc97a", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In the SysML modeling framework, a Package serves as a fundamental organizational unit for grouping, encapsulating, and modularly managing model elements. Within the .xmi file format, uml:Package acts as the top-level container for all structures, nesting other model elements such as classes (uml:Class), interfaces (uml:Interface), use cases (uml:UseCase), data types (uml:DataType), as well as subordinate packages (uml:Package) through the <packagedElement> tag. This nested structure allows modelers to organize system structure and behavior hierarchically, ensuring clear layering and manageable logic.\n\nIn practice, each uml:Package element typically has a unique xmi:id and a name attribute, where the name reflects the logical name of the package. The naming should follow consistent conventions\u2014such as \"1-Requirements\", \"2-Structure\", \"3-Use Cases\"\u2014to represent the thematic content and functional classification of the package. Each Package may contain any number of packagedElement items, which constitute the specific content within that package.\n\nStructurally, Package nesting is recursive, allowing construction of arbitrary hierarchical package structures. For example, a top-level package like \u201cSpacecraft Mission Context\u201d can include sub-packages such as \u201c1-Requirements,\u201d \u201c2-Structure,\u201d and \u201c3-Use Cases.\u201d These sub-packages can be further refined internally\u2014for instance, the \u201c2-Structure\u201d package may define specific Blocks, Associations, Abstractions, and other structural elements. In modeling tools like MagicDraw, such hierarchical packaging facilitates diagram management, access control, and team collaboration.\n\nModelers should adhere to the following principles when using Packages:\n\nSemantic Consistency and Naming Conventions: Package names should reflect their domain content. Using ordered numbering (e.g., \"1-Requirements\", \"2-Structure\") improves model navigability and ensures consistent documentation exports.\n\nElement Encapsulation: All model elements such as uml:Class, uml:Association, uml:Activity, uml:Signal, etc., must belong to some Package to maintain ordered model structure. This facilitates import/export, subsystem reuse, and unit verification.\n\nCross-Package Referencing Mechanism: Although elements reside in different packages, cross-package references are possible using XMI\u2019s xmi:idref mechanism (e.g., Association ends may reside in separate packages). This supports modular and decoupled system design.\n\nModel Specialization Management: Packages can semantically inherit or specialize one another via Import, Merge, or custom extensions. For example, general elements can be placed in a \u201c10-Supporting Elements\u201d package and referenced/shared by multiple other packages.\n\nModel Reuse and Distribution Support: Common models (such as signals, states, general data types) can be separated into standalone Packages for reuse, improving modeling efficiency and consistency. In collaborative engineering, responsibility for model parts can be assigned by package.\n\nCoordination with Behavioral Elements: Within .xmi, Packages can include behavioral elements (e.g., uml:Activity, uml:StateMachine, uml:SignalEvent) as packagedElement. Relationships such as Abstraction, Allocate, and Refine can link these behaviors to structural elements, forming semantic mappings between structure and behavior.\n\nFurthermore, under SysML\u2019s extension mechanisms, structural elements within a package can be stereotyped (e.g., sysml:Block, sysml:ValueProperty, sysml:Allocate). These stereotypes are generally applied via another element (such as MD_Customization_for_SysML__additional_stereotypes:ValueProperty) referencing the original UML element through base_* properties. It is important that these stereotype bindings reference elements within the current package or packages referenced by it to avoid semantic drift or model inconsistencies.\n\nIn summary, Package is the core unit in SysML models that carries modular structure, behavioral content, and system relationships. By designing rational package structures and hierarchical organizations, models gain maintainability, reusability, and extensibility, providing a foundational mechanism to support modeling of large, complex systems. Modelers should build sustainable systems engineering model architectures based on clear semantics, well-defined structure, and rational referencing.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4381, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6330aa95-eb6a-4085-8763-360ff8fc0f60": {"__data__": {"id_": "6330aa95-eb6a-4085-8763-360ff8fc0f60", "embedding": null, "metadata": {"source": "SEQ-Interaction.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "bb4e85e0-4637-4cf3-9661-ab5752f3c508", "node_type": "4", "metadata": {"source": "SEQ-Interaction.txt"}, "hash": "0a5d628730ad151f6702c6d182de5ae4fa3dbbd2939977987df5e46252093bf6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In SEQ models, Interaction serves as the core behavioral element of sequence diagrams, primarily used to describe the process of message exchanges between objects within a system and their temporal relationships. This element employs various internal structures and rules to precisely express behavioral constraints, timing characteristics, and message flows during interactions.\n\nFirst, an Interaction contains several ownedRule elements, which typically manifest as DurationConstraint instances. These constraints limit the time intervals during which certain events or messages occur within the interaction. Each DurationConstraint associates with constrained event nodes via the constrainedElement attribute and uses a DurationInterval to specify the minimum and maximum allowable duration. Such constraints ensure that the model\u2019s timing conforms to system design requirements by precisely defining temporal gaps between events.\n\nSecond, the Interaction includes multiple observation elements, usually of type DurationObservation, which observe and record the duration of events. These observations reference events via the event attribute, which link to the exact time points of message sending or receiving. These observation points provide concrete measurements to support duration constraints, ensuring traceability and verifiability of timing-related rules.\n\nAdditionally, Interaction defines multiple formalGate elements, serving as formal message entry and exit points that clearly mark the boundaries for message sending and receiving within the interaction. These Gates connect and control message flows through their association with message elements, supporting clear definition of message transmission paths.\n\nThe Interaction also contains fragment elements such as MessageOccurrenceSpecification and CombinedFragment. The MessageOccurrenceSpecification marks specific message send or receive events and associates with corresponding covered regions on lifelines. The CombinedFragment expresses complex control structures by specifying an interactionOperator (e.g., the \u201cpar\u201d operator for parallel execution), enabling semantic representation of concurrency, choice, loops, and other control flows. Inside CombinedFragments, multiple InteractionOperand elements further subdivide interaction paths and conditions and can nest StateInvariant constraints to ensure that certain state properties hold valid at specific moments during the interaction.\n\nRegarding lifelines, these represent the objects or roles participating in the interaction. The Interaction explicitly identifies participants and their active scopes via lifelines. Each lifeline is associated with the interaction fragments it covers through coveredBy, indicating the active intervals and message handling periods for that participant.\n\nMessages in Interaction reflect the concrete communication content and temporal order between objects. Message properties include messageSort (denoting message type, e.g., asynchronous signal), sendEvent, and receiveEvent, which specify the exact sending and receiving time points, thus guaranteeing the completeness and logical sequence of message flows.\n\nIn summary, the modeling rules for Interaction in SEQ emphasize a comprehensive and precise description of system temporal interaction behaviors and timing constraints. This is achieved through the integrated use of duration constraints, duration observations, formal message gates, message occurrence specifications, combined fragments, lifelines, and message elements. These rules not only facilitate clear behavioral expression but also provide a solid foundation for model verification, analysis, and simulation.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3693, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "d8a96758-b321-4c81-8f0c-880bcdeee68a": {"__data__": {"id_": "d8a96758-b321-4c81-8f0c-880bcdeee68a", "embedding": null, "metadata": {"source": "IBD-ItemFlow.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "a01d77dd-6adc-40ad-ae22-821fa0ce3912", "node_type": "4", "metadata": {"source": "IBD-ItemFlow.txt"}, "hash": "5eb29a69b1c0477d3f481e65f3b63c3bb58d36e5be7035d674115a783b50af04", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In SysML\u2019s Internal Block Diagram (IBD), ItemFlow is a specialization of InformationFlow, used to describe the types and directions of physical objects, energy, or data items transmitted through structural connectors (Connectors). Compared to the abstract nature of InformationFlow, ItemFlow emphasizes the specific \u201cflowing content\u201d and its implementation path along structural connections. In XMI representation, ItemFlow is modeled by the sysml:ItemFlow element, whose base_InformationFlow attribute references a pre-defined uml:InformationFlow element, which specifies the transmitted content, source, target, and the associated connector.\n\nKey Aspects of ItemFlow\nEach ItemFlow depends on a corresponding InformationFlow that clearly defines the conveyed property representing the transferred item\u2014typically a uml:Class denoting information, signals, data, etc.\n\nThese conveyed items should have unique identifiers (xmi:id) and be pre-defined within the model.\n\nFor example, in a thermal control subsystem, \"Heater Control\" or \"Temperature Signal\" can be defined as conveyed items for control signals and measurement signals respectively.\n\nStructural Relationships\nThe base_InformationFlow of an ItemFlow must explicitly specify informationSource and informationTarget, which are usually Ports or Properties.\n\nThese elements should reside within concrete Blocks and be consistent with the actual UML Connector ends (ConnectorEnd) to properly associate the structural connection and information flow paths.\n\nSemantic Consistency Between Structure and Behavior\nTo ensure semantic consistency, each InformationFlow is recommended to use the realizingConnector attribute to reference a uml:Connector element.\n\nThis Connector represents the physical or logical path for information transmission in the structural diagram and typically consists of two ConnectorEnds corresponding to the InformationFlow\u2019s source and target.\n\nWithin the IBD, this structural mapping clarifies what is transmitted along which connection via the ItemFlow.\n\nModeling Best Practices\nEach ItemFlow should have a clear name and use precise ConnectorEnd and propertyPath references to support model traceability and system verification.\n\nItemFlow is particularly suitable for scenarios requiring modeling of concrete data or energy transmission, such as electric power, temperature signals, or control commands\u2014whether physical entities or abstract information.\n\nWhen combined with FlowPort or FullPort, ItemFlow can further enhance directionality and type consistency, achieving more complete semantic modeling.\n\nModeling Constraints and Considerations\nModelers must ensure the conveyed items exist in the model and have logically clear contexts.\n\nIt is invalid to create ItemFlows for classes or ports that are undefined or not bound to connectors, as this causes inconsistencies or verification failures.\n\nEspecially during system simulation or code generation, the type information provided by ItemFlow is a critical modeling basis.\n\nSummary\nItemFlow is an essential mechanism for structured, type-safe modeling of information/data transmission. It is suitable for system engineering projects with high fidelity requirements. By explicitly defining the transmitted item, connection path, and modeling context, ItemFlow builds a bridge between structural connectors and system behavior, significantly enhancing model expressiveness and verifiability.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3427, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "584c67de-6794-43a2-907b-5752a6629368": {"__data__": {"id_": "584c67de-6794-43a2-907b-5752a6629368", "embedding": null, "metadata": {"source": "BDD-Block.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2bcca698-fed6-4137-8ade-567417ec6e77", "node_type": "4", "metadata": {"source": "BDD-Block.txt"}, "hash": "fbc6fb492d2c4ff4f9c65244818aee8060b60878c283d6c3d8da5ea671b2b67f", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In XMI-formatted SysML models, model elements are represented by packagedElement as core nodes for various UML/SysML elements. Their attributes and relationships are expressed via nested child elements. Specifically for systems engineering modeling needs, key objects include Block, Property (especially ValueProperty, PartProperty, and ReferenceProperty), Port, Operation, and behavioral elements. The following rules apply to general SysML model construction compliant with this format, ensuring semantic accuracy and clear structure.\n\n1. Block Modeling Rules\nA Block is the primary modeling unit of a system, typically mapped as a packagedElement of type uml:Class, and stereotyped with sysml:Block for SysML semantics. Blocks represent physical or logical entities in the system. Modeling rules include:\n\nEach Block must define a unique xmi:id and name attribute to ensure element uniqueness and identifiability.\n\nA Block may own multiple attributes (ownedAttribute), which must specify their type (pointing to corresponding DataType or Class elements) and aggregation kind (e.g., composite or shared) to reflect part-whole or reference relationships.\n\nBlocks can define behaviors (ownedBehavior), such as state machines (StateMachine), associated via the classifierBehavior attribute to describe lifecycle or state transitions.\n\nOperations corresponding to the Block\u2019s behavior are defined via ownedOperation, requiring clear operation names and visibility; these operations represent the Block\u2019s functional responsibilities.\n\nStructural reuse and polymorphism are realized via inheritance (generalization), where child Blocks redefine parent properties using mechanisms like redefinedProperty, supporting refinement or overriding of attributes.\n\n2. Property Modeling Rules\nProperties are the core structural components of Blocks, describing intrinsic characteristics. SysML refines Properties based on semantic meaning:\n\nValueProperty: Represents quantitative features of a Block, such as mass, power, or life, typically holding concrete values. ValueProperties should be stereotyped with MD_Customization_for_SysML__additional_stereotypes:ValueProperty and link their base_Property to the actual ownedAttribute.\n\nPartProperty: Represents internal parts composing the Block, reflecting composite relationships to other Blocks, indicating physical nesting. PartProperties must have aggregation kind composite and associate with specific sub-Block types, supporting hierarchical modeling.\n\nReferenceProperty: Represents references to external elements, not ownership relationships, usually with aggregation kind shared. Used to describe dependencies, associations, or shared data relationships. Identified by the stereotype MD_Customization_for_SysML__additional_stereotypes:ReferenceProperty.\n\n3. Port Modeling Rules\nPorts define interface points for Blocks interacting with the external environment or other Blocks, representing physical or logical input/output connections. Modeling requirements include:\n\nPorts are a kind of ownedAttribute with type uml:Port, requiring clear names and visibility.\n\nThe type attribute of Ports should reference defined interface classes or Blocks (e.g., LV electrical interface, ground command & data interface), ensuring semantic clarity of the interface.\n\nAggregation kind is typically composite, indicating that the Port is part of the Block.\n\nIt is recommended to set appropriate interface constraints and behavioral specifications on Ports to support interface consistency and interaction modeling.\n\n4. Operation Modeling Rules\nOperations define executable behavioral functions of a Block and are key to behavioral modeling:\n\nEach Operation should be defined in the Block\u2019s ownedOperation section, with unique names and specified visibility.\n\nOperations may have parameters and return values; although not always fully expressed in XML fragments, complete definitions are recommended to support interface contracts.\n\nOperation names should be semantically clear and aligned with system functional requirements (e.g., \u201ccontrol attitude,\u201d \u201cmanage faults\u201d).\n\nOperations should be integrated with signals (Reception) and state machine trigger events to realize behavior-driven execution.\n\n5. Behavior and State Machine Modeling Rules\nBlocks may own state machine behaviors describing state transitions and lifecycle:\n\nState machines are linked via ownedBehavior nodes, of type uml:StateMachine, and should define comprehensive states, events, and transitions.\n\nThe state machine is linked to the Block\u2019s dynamic behavior through the classifierBehavior property.\n\nIt is recommended to provide clear triggering conditions and behavior action descriptions for state machines to facilitate simulation and verification.\n\n6. Inheritance and Redefinition Rules\nTo support layered system design and reuse:\n\nInheritance among Blocks is realized through generalization, where child Blocks explicitly specify their parent via the general property.\n\nChild Blocks can refine or replace inherited properties from parent Blocks using the redefinedProperty mechanism, enhancing model flexibility and extensibility.\n\nThe inheritance hierarchy should follow principles of clear layering and well-defined responsibilities, avoiding property conflicts and redundant definitions.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 5300, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "26f5fe45-3c92-4ea3-92f7-1882b4e4d12e": {"__data__": {"id_": "26f5fe45-3c92-4ea3-92f7-1882b4e4d12e", "embedding": null, "metadata": {"source": "UCD-UseCase.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "8b927282-8eb0-437d-9cf7-0ac2b53e4696", "node_type": "4", "metadata": {"source": "UCD-UseCase.txt"}, "hash": "4e9d0d14df827b8d7fc65e391569aec868ec420e0ca98c8914de03309e159126", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Use Cases are the core elements in Use Case Diagram (UCD) modeling, used to describe the functions or services a system provides to satisfy specific stakeholder needs. Each Use Case must have a clear and unique name to explicitly define its business purpose and scope. The name should accurately reflect the specific business activity or functional requirement represented by the Use Case, ensuring the model\u2019s expression is precise and easily understandable.\n\nUse Cases are generally organized within Packages for classification and management, often grouped by business domain, system functional modules, or task objectives to facilitate structured management and reuse. This hierarchical organization keeps the model well-ordered while supporting decomposition and refinement of complex system functions.\n\nBetween Use Cases, \u201cinclude\u201d and \u201cextend\u201d relationships are commonly used to express reuse and variation logic. The include relationship represents a sub-function that is always executed as part of the including Use Case, embodying modularity and reuse of functionality. For example, a complex \u201cPerform Task\u201d Use Case may include multiple base Use Cases to complete its workflow. The extend relationship, on the other hand, indicates that a Use Case behavior is conditionally extended by another Use Case, supporting variation points and exception handling scenarios, such as an emergency Use Case triggered during fault detection.\n\nUse Cases are connected to Actors (Stakeholders) via Associations, clarifying who initiates or participates in the Use Case, thus reflecting the system functionality\u2019s users and responsibility ownership. This association relationship is key to requirements analysis, helping to clarify the origin of requirements and functional boundaries.\n\nAdditionally, Use Cases may define Extension Points, which reserve specific locations within the base Use Case for future extensions or system adaptability, thereby enhancing model flexibility and maintainability. Extension Points are typically identified at certain steps or states of the base Use Case, providing structured insertion points for extending Use Cases.\n\nThe Use Case model also supports mapping to business requirements; some Use Cases can be linked to system Requirements or other business rules to enable traceability and verification, ensuring the system functionality fully covers the business objectives.\n\nSummary of Use Case Modeling Rules in UCD\nDefine Use Cases with clear, unique names that accurately represent their business purpose.\n\nOrganize Use Cases within packages by business domain or functional grouping for structured management.\n\nUse include and extend relationships to model reuse and behavioral variations among Use Cases.\n\nAssociate Use Cases with Stakeholders (Actors) to specify users and responsibility boundaries.\n\nDefine Extension Points in Use Cases to support flexible future extensions.\n\nLink Use Cases with system requirements to enable traceability and verification.\n\nAdhering to these rules enables the construction of clear, complete, and maintainable system functional models that meet high-quality requirements for analysis and design.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3171, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "0367fccd-0f55-48da-a23f-9d199f99aae6": {"__data__": {"id_": "0367fccd-0f55-48da-a23f-9d199f99aae6", "embedding": null, "metadata": {"source": "IBD-BindingConnector.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "c1034ead-36ad-46d6-a460-ee9a02c113d6", "node_type": "4", "metadata": {"source": "IBD-BindingConnector.txt"}, "hash": "b4b7eaa8dcbcfd6d2dc21e0bbbfdd0fc16fe1dfd61c06022d0223f14dda6a906", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In SysML\u2019s Internal Block Diagram (IBD), a BindingConnector is a type of connector used to express binding constraints. Its core purpose is to bind parameters or properties of different parts within the model, ensuring these elements maintain consistent values or states during model instantiation and simulation.\n\nBindingConnector Representation in XMI\nThe BindingConnector is typically represented as a UML Connector element, stereotyped with sysml:BindingConnector in SysML.\n\nThis connector is generally defined inside a Block or composite structure, connecting two endpoints (ConnectorEnd), which correspond to parts (subcomponents) or ports of the Block.\n\nUnlike typical connectors that represent information or signal flow, the BindingConnector emphasizes value binding relationships between the endpoints.\n\nXMI Structure Details\nThe BindingConnector references the UML connector through the base_Connector property.\n\nIts two endpoints are represented by ConnectorEnd elements, each linked to a specific part or port.\n\nTo support precise binding within complex hierarchical structures, the endpoints may be further specified by sysml:NestedConnectorEnd, which includes a propertyPath attribute that clearly defines the chain of properties involved in the binding path.\n\nPractical Use Case\nBindingConnectors are often used to connect subcomponent properties within a Block.\n\nFor example, within an \u201cAnalysis Context\u201d Block, a property named \u201ccea\u201d might correspond to a port or property of the \u201cCost Effectiveness Analysis Model\u201d Block.\n\nThe BindingConnector connects \u201ccea\u201d to another property like \u201ccost,\u201d ensuring that these two are bound to maintain consistency.\n\nThe propertyPath on the endpoints defines the exact hierarchical path to the bound properties, enabling accurate resolution of binding relationships.\n\nDesign Intent and Significance\nThe use of BindingConnector reflects SysML\u2019s design philosophy of parameter consistency and constraint propagation within models.\n\nIt guarantees synchronization of values across different levels and modules of the system, which is particularly crucial during system simulation and verification.\n\nBindingConnector differs from ordinary connectors by focusing on binding parameters or properties rather than signaling flows.\n\nSupport for Nested Structures\nBindingConnector works in conjunction with NestedConnectorEnd to support cross-layer bindings in complex nested structures.\n\nThis demonstrates SysML\u2019s capability for modular and multi-level parameter management in complex system designs.\n\nSummary of BindingConnector Modeling Rules in IBD\nBased on UML Connector and stereotyped as sysml:BindingConnector to express binding semantics.\n\nConnects two parts or ports within a Block, with endpoints specified via ConnectorEnd.\n\nUses NestedConnectorEnd and propertyPath to precisely describe the binding property paths, supporting complex hierarchical structures.\n\nEmbodies parameter binding and consistency constraints, enabling cross-module and cross-level synchronization of system parameters.\n\nEssential for parameter consistency validation and simulation; a key mechanism for parameter propagation and constraint implementation.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3184, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "91dab8aa-63b2-4f6d-a1e7-3e0a7bac30f4": {"__data__": {"id_": "91dab8aa-63b2-4f6d-a1e7-3e0a7bac30f4", "embedding": null, "metadata": {"source": "UCD-Stakeholder.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "0c930bab-70f1-4ac4-9f96-68413bc6abfd", "node_type": "4", "metadata": {"source": "UCD-Stakeholder.txt"}, "hash": "55a39cf9e957547a5c16acf16eaf2525bb7a0a0cbfc5d5b714292c19b1b9ff76", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "Modeling Rules for Stakeholders in UCD\nIn the Use Case Diagram (UCD), Stakeholders are typically modeled as Actors, representing entities external to the system that interact with it. These can be people, organizations, systems, or other interest groups. The definition of an Actor must clearly specify its name and identity to ensure that a particular stakeholder is uniquely identified within the model. For example, the Fire Department is defined as an Actor using the <packagedElement xmi:type=\"uml:Actor\" ... name=\"Fire Department\"/> construct.\n\nThe attributes of an Actor can be further refined by associations or extensions that express its specific roles and responsibilities. In SysML or UML, an Actor can be linked via generalization relationships to more specialized role classes (such as \u201cViewpoint\u201d or \u201cView\u201d classes), forming a hierarchy that reflects different stakeholder perspectives and concerns within the system. For instance, in the example, \u201cFire Department Viewpoint\u201d and \u201cFire Department View\u201d are connected through generalization relationships to the \u201cFire Department\u201d Actor, supporting the expression of requirements and separation of views.\n\nWhen modeling Stakeholders, Actors should be connected to Use Cases via association relationships, reflecting the stakeholders\u2019 requirements for or participation in system functions. Use Cases are defined by <packagedElement xmi:type=\"uml:UseCase\" ...>. The relationships between Stakeholders (Actors) and Use Cases are typically expressed as Associations or Dependencies, indicating how stakeholders trigger or engage with system behavior. For example, there is an association between the \u201cFire Department\u201d Actor and the Use Case \u201cDetect and Monitor Forest Fires in US and Canada,\u201d showing that this stakeholder needs or participates in that system functionality.\n\nMoreover, modeling the internal attributes of an Actor is an important aspect, especially when refining the composition of a Stakeholder. In the example, the Fire Department Actor contains multiple ownedAttribute elements, described via composite aggregation (aggregation=\"composite\") to represent its constituent subparts (PartProperties). This supports structured and hierarchical management of the model. These attributes usually identify the concrete entities or subsystems that compose the Stakeholder, helping to illustrate its internal organizational structure.\n\nTo enhance model readability and contextual understanding, related elements often include comments that describe business meanings and design intentions. The example uses <ownedComment> to explain the business objectives of each viewpoint and role, facilitating the clarification and communication of stakeholder requirements.\n\nSummary of Stakeholder Modeling Rules in UCD\nClear Actor Definition: Each Stakeholder must be defined as a unique Actor element with a clear name and identifier.\n\nHierarchical Role Expression: Use Generalization relationships to establish hierarchical structures of viewpoints and views, meeting the needs of diverse stakeholder perspectives.\n\nUse Case Association: Stakeholders must be connected to system Use Cases through associations to reflect requirements involvement and trigger relationships.\n\nInternal Structure Refinement: Describe the internal composition of Actors via composite aggregation attributes, showing specific constituent parts of the stakeholder.\n\nAdditional Annotations: Use comments to explain business goals and design background, enhancing semantic clarity.\n\nThese rules ensure that Stakeholder modeling in UCD is systematic, hierarchical, and comprehensible, facilitating subsequent system requirements analysis and design processes.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3694, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "125d6b2a-8989-4570-a2e2-7bcdd51a5795": {"__data__": {"id_": "125d6b2a-8989-4570-a2e2-7bcdd51a5795", "embedding": null, "metadata": {"source": "STM-StateMachine.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "1dd2177c-40ad-49ee-a14c-7d8180ec7a00", "node_type": "4", "metadata": {"source": "STM-StateMachine.txt"}, "hash": "62059ff7138444f7dc8946b61e5b21efa9b351003a7f9986f21151f01545a5ec", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "The StateMachine is a core element in behavioral modeling, used to describe the possible states a system or object may experience throughout its lifecycle and the transitions between these states. Its modeling mainly follows the following rules:\n\n1. Structural Hierarchy of StateMachine\nA StateMachine usually consists of one or more Region elements. A Region is a container for states. Each Region contains multiple subvertices, including State, Pseudostate (such as initial, choice, history nodes), and FinalState.\n\nRegion: A logical area within a state machine that manages states; it supports parallel regions to implement concurrent behaviors in composite states.\n\nState: Represents a specific state, which may contain nested Regions to denote composite states.\n\nPseudostate: Special nodes within the state machine, such as initial nodes, choice nodes, and history nodes, typically used as control flow starting points or decision nodes.\n\nFinalState: Represents a terminating state of the state machine.\n\n2. Nested States and Composite States\nStates can contain internal Regions, forming a hierarchical state structure. Composite states allow multiple parallel Regions inside a single state, enabling multithreaded state behavior. This hierarchical design supports the modeling of complex state machine behaviors.\n\nFor example, a State element may include nested Regions, each containing several subvertices, supporting state partitioning at different hierarchical levels.\n\n3. State Behavior Description\nEach state may define various behaviors:\n\ndoActivity: Activities executed continuously while the state is active, usually represented by an Activity diagram element containing ControlFlows, ObjectFlows, and Nodes that describe detailed behaviors during state activation.\n\nEntry and Exit Activities: Actions executed upon entering or exiting the state (common in modeling though not shown in the example).\n\nInternal Event Handling: The state machine can respond to events triggering behaviors, described via Trigger and Event elements.\n\n4. Transitions\nStates are connected by Transition elements that define the path from a source state to a target state.\n\nEach Transition may contain a guard condition that restricts when the transition can occur.\n\nTrigger defines the event that initiates the transition; common triggers include signals, clocks, or conditions.\n\nTransitions are directed and must specify the source and target states explicitly.\n\nMultiple transitions can exist between states to represent complex switching logic.\n\n5. Events and Triggers\nEvents serve as triggering conditions for transitions and are typically referenced within Trigger elements. Events can be:\n\nSignal events (Signal),\n\nCall events (Call),\n\nTime events (Time), etc.\n\nTransitions driven by events propel the dynamic behavior of the state machine.\n\nFor example, signals are defined as Signal elements within the state machine and can trigger state transitions.\n\n6. Integration of Activity Diagrams with StateMachine\nThe doActivity inside a state can be detailed using the structure of an Activity Diagram, including control flows, object flows, call behavior actions (CallBehaviorAction), and partitions (ActivityPartition). This integration supports detailed behavioral modeling combining activity diagrams and state machines.\n\n7. Visibility and Identification\nAll state machine elements support a visibility attribute, commonly set to public.\n\nEach element possesses a unique xmi:id identifier to ensure internal uniqueness and traceability.\n\nThe name attribute labels the element for ease of recognition and understanding of the model structure.\n\n8. Resource Allocation\nState machines also support modeling of resource allocation. For example, the stereotype sysml:AllocateActivityPartition can associate state machine activities with specific resources or system partitions to support resource management in systems engineering.\n\nSummary\nIn the STM (State Machine Modeling), StateMachines follow principles of hierarchy and modularity. Regions manage states, and States and Pseudostates form a complete state structure. Transitions connect states and are driven by triggers and events. State behaviors are refined using activity diagrams, supporting complex control flows and detailed behaviors. Through resource allocation extensions, state machine models can also reflect system resource assignments. Overall, STM\u2019s StateMachine modeling rules aim to efficiently and clearly express dynamic system behaviors, meeting the demands of complex systems engineering.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 4557, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "6ccf23c8-93db-483f-9bbb-5527f4ba18d3": {"__data__": {"id_": "6ccf23c8-93db-483f-9bbb-5527f4ba18d3", "embedding": null, "metadata": {"source": "REQ-Trace.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "df23f068-69be-4627-86c5-b134e8ca7dd4", "node_type": "4", "metadata": {"source": "REQ-Trace.txt"}, "hash": "5c8d8fdfaf8e815cb139c5750df3cd88a2d5f201c1477f93b8b80f75fb2867f5", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In SysML requirements modeling, the Trace relationship is used to represent traceability links between requirements themselves or between requirements and other model elements. It is a crucial tool for requirements management and verification. Typically, Trace is implemented as a uml:Abstraction element, with the following fundamental usage and rules:\n\nStructure Implementation of Trace\nThe Trace relationship is usually represented in the XMI file as a uml:Abstraction element, which contains two core attributes: client and supplier. The client refers to the traced (dependent) requirement element, while the supplier refers to the source requirement or model element being traced to. SysML further specifies this uml:Abstraction as a Trace type through the <sysml:Trace> stereotype tag, which references the corresponding uml:Abstraction via the base_Abstraction attribute.\n\nTarget and Context of Trace\nTrace commonly connects two sysml:Requirement elements, indicating that one requirement originates from or is associated with another.\n\nIt can also connect requirements to other system model elements (such as classes or components), to demonstrate the mapping between requirements and design elements.\n\nRequirement elements themselves reference UML Class elements via the base_Class attribute, serving as the concrete implementation carrier of the requirement.\n\nHierarchy and Nesting\nRequirements models often adopt layered, nested structures to organize requirements. Trace relationships can be established across different hierarchy levels, such as tracing from top-level requirements to more detailed child requirements, supporting decomposition and refined management.\n\nRequirement ID and Text Attributes\nEach sysml:Requirement contains an Id field, which uniquely identifies the requirement number, and a Text field describing the requirement content. The Trace relationship does not directly affect these attributes but helps clarify the logical connections among requirements by linking them.\n\nApplication Scenarios of Trace\nRequirements Traceability: Enables source tracking between requirements, facilitating change management and verification.\n\nRequirements Origin Analysis: Confirms which requirements underpin design decisions.\n\nVerification and Validation Support: Assists testing and validation activities to ensure design compliance with requirements.\n\nTypical XMI Representation of Trace\nTaking an example, the uml:Abstraction defines the Trace connection, with client and supplier corresponding respectively to the start and end requirements. The sysml:Trace stereotype binds this relationship via the base_Abstraction attribute, making it a SysML Trace instance.\n\nRepresentation in Modeling Tools\nIn tools, Trace relationships may appear as connecting lines between two requirements or between requirements and other model elements.\n\nIt is important to ensure uniqueness and clarity of requirement elements\u2019 hierarchical structure so that Trace relationships are correctly established.\n\nMaintaining complete requirement IDs and textual descriptions is recommended to facilitate subsequent trace analysis.\n\nIn summary, the core rule of SysML Trace modeling is to use the uml:Abstraction element to establish traceability links between requirements, explicitly defining the semantics with the sysml:Trace stereotype. This relationship supports hierarchical requirement management, change impact analysis, and design verification, ensuring traceability and standardization throughout the systems engineering process.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 3539, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}, "2d3f7bd6-6f18-4394-bb33-fdbad5a17203": {"__data__": {"id_": "2d3f7bd6-6f18-4394-bb33-fdbad5a17203", "embedding": null, "metadata": {"source": "BDD-ValueType.txt"}, "excluded_embed_metadata_keys": [], "excluded_llm_metadata_keys": [], "relationships": {"1": {"node_id": "2f067223-edf3-46d0-943b-426408cb26b0", "node_type": "4", "metadata": {"source": "BDD-ValueType.txt"}, "hash": "8b4213ea1c0ee489c4c8f76d744bd1e47ddedd4e3bc8423243bc65492ce6cbc6", "class_name": "RelatedNodeInfo"}}, "metadata_template": "{key}: {value}", "metadata_separator": "\n", "text": "In SysML\u2019s Block Definition Diagram (BDD), ValueType is a special data type used to describe quantities with explicit numerical meaning within the system, such as physical quantities and units. It is typically represented in the model as a uml:DataType element and distinguished from ordinary data types and classes by the sysml:ValueType stereotype.\n\nKey points in the definition of ValueType include:\n\nFirst, a ValueType appears in the XMI file as a uml:DataType element with a unique xmi:id and a corresponding name attribute, such as \u201cDrag Force\u201d or \u201cForce\u201d in examples. This represents the actual data type entity corresponding to the ValueType. The ValueType is linked to this uml:DataType element via the sysml:ValueType stereotype, i.e., the base_DataType property points to the associated uml:DataType, thereby integrating SysML semantics with UML.\n\nSecond, ValueTypes can inherit from other data types, enabling hierarchical modeling of numerical types. For example, in the case, \u201cDrag Force\u201d inherits from \u201cForce,\u201d which in turn inherits from the standard SysML library\u2019s Real type. This inheritance is expressed through generalization elements, allowing reuse and extension of different numerical types within the model, in accordance with object-oriented design principles.\n\nAdditionally, ValueTypes generally do not contain complex behaviors (operations) or states but focus on defining their numerical properties and structure. They are essentially immutable, emphasizing the semantics of the value rather than object identity or lifecycle.\n\nFinally, ValueTypes are designed for integration with other model elements, such as property types in Blocks, which can directly use the numerical types defined by ValueTypes. This ensures consistency and standardization of data types across the system model.\n\nIn summary, the modeling rules for ValueType in BDD emphasize constructing hierarchical data types through inheritance, applying the SysML ValueType stereotype to uml:DataType elements, and focusing on the expression of values. These rules meet systems engineering requirements for precise definition of physical quantities and units.", "mimetype": "text/plain", "start_char_idx": 0, "end_char_idx": 2152, "metadata_seperator": "\n", "text_template": "{metadata_str}\n\n{content}", "class_name": "TextNode"}, "__type__": "1"}}, "docstore/ref_doc_info": {"46fda17c-fd7c-4f43-8eaf-aa58a9531ebe": {"node_ids": ["c95fb17b-2553-427e-966b-045cc05109dd"], "metadata": {"source": "BDD-ConstraintBlock.txt"}}, "293445b0-465b-49b5-b517-0c869601d77d": {"node_ids": ["ae47491a-36a0-4f80-9434-b32feb1d0985"], "metadata": {"source": "IBD-Connector.txt"}}, "3803b18f-57e0-4c59-8106-12d18adc0648": {"node_ids": ["6d38edb5-1393-4751-88e8-31d2ecb21a5e"], "metadata": {"source": "BDD-InterfaceBlock.txt"}}, "c6ce15b1-05b9-4a69-9cdd-eb2e6c5295ea": {"node_ids": ["666e0a62-1468-41a4-8d81-11ea7cc5ebd4"], "metadata": {"source": "IBD-InformationFlow.txt"}}, "75f34c2a-2661-426e-8f81-f92a47f50793": {"node_ids": ["cb64e6ac-e3a9-4398-be8b-3711862b9377"], "metadata": {"source": "ACT-TestCase.txt"}}, "6aad01c3-03fd-4b73-9317-67e62f52ee96": {"node_ids": ["d8f96c30-788d-411c-a321-a07fa98d296a"], "metadata": {"source": "ACT-Activity.txt"}}, "01f79bd1-86ef-4063-a6a9-97aaa358fb88": {"node_ids": ["57a62429-a7b4-461e-a3b5-05aabea429d8"], "metadata": {"source": "REQ-DeriveReqt.txt"}}, "222fe9a6-40dd-4662-bb07-52ec7b41a965": {"node_ids": ["ba4d9ecc-ddf2-4f9e-9222-88f74b03daca"], "metadata": {"source": "PAR-caused_by.txt"}}, "68f29305-67de-47e8-a243-991e98ccaacb": {"node_ids": ["c41409e5-42f0-423c-b65c-0144237b2c31"], "metadata": {"source": "REQ-Requirement.txt"}}, "ec7cccb9-2f84-4cb3-b031-7a2bcd76bb28": {"node_ids": ["7f393dc7-7e4d-431b-ac35-4cad5b185614"], "metadata": {"source": "PKG-Package.txt"}}, "bb4e85e0-4637-4cf3-9661-ab5752f3c508": {"node_ids": ["6330aa95-eb6a-4085-8763-360ff8fc0f60"], "metadata": {"source": "SEQ-Interaction.txt"}}, "a01d77dd-6adc-40ad-ae22-821fa0ce3912": {"node_ids": ["d8a96758-b321-4c81-8f0c-880bcdeee68a"], "metadata": {"source": "IBD-ItemFlow.txt"}}, "2bcca698-fed6-4137-8ade-567417ec6e77": {"node_ids": ["584c67de-6794-43a2-907b-5752a6629368"], "metadata": {"source": "BDD-Block.txt"}}, "8b927282-8eb0-437d-9cf7-0ac2b53e4696": {"node_ids": ["26f5fe45-3c92-4ea3-92f7-1882b4e4d12e"], "metadata": {"source": "UCD-UseCase.txt"}}, "c1034ead-36ad-46d6-a460-ee9a02c113d6": {"node_ids": ["0367fccd-0f55-48da-a23f-9d199f99aae6"], "metadata": {"source": "IBD-BindingConnector.txt"}}, "0c930bab-70f1-4ac4-9f96-68413bc6abfd": {"node_ids": ["91dab8aa-63b2-4f6d-a1e7-3e0a7bac30f4"], "metadata": {"source": "UCD-Stakeholder.txt"}}, "1dd2177c-40ad-49ee-a14c-7d8180ec7a00": {"node_ids": ["125d6b2a-8989-4570-a2e2-7bcdd51a5795"], "metadata": {"source": "STM-StateMachine.txt"}}, "df23f068-69be-4627-86c5-b134e8ca7dd4": {"node_ids": ["6ccf23c8-93db-483f-9bbb-5527f4ba18d3"], "metadata": {"source": "REQ-Trace.txt"}}, "2f067223-edf3-46d0-943b-426408cb26b0": {"node_ids": ["2d3f7bd6-6f18-4394-bb33-fdbad5a17203"], "metadata": {"source": "BDD-ValueType.txt"}}}}